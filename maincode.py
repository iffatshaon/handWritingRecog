# -*- coding: utf-8 -*-
"""mainCode.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tK4RwY_fHthBf1-z1yziqKEnec1qc8BF
"""

import cv2
import numpy as np
import imutils
from matplotlib import pyplot as plt
from operator import add
import tensorflow as tf
from tensorflow import keras
from PIL import Image, ImageOps
from keras.preprocessing import image
from keras.models import load_model

def rotateImage(mat, angle):
    height, width = mat.shape[:2]
    image_center = (width/2, height/2)
    rotation_mat = cv2.getRotationMatrix2D(image_center, angle, 1.)
    abs_cos = abs(rotation_mat[0,0])
    abs_sin = abs(rotation_mat[0,1])
    bound_w = int(height * abs_sin + width * abs_cos)
    bound_h = int(height * abs_cos + width * abs_sin)
    rotation_mat[0, 2] += bound_w/2 - image_center[0]
    rotation_mat[1, 2] += bound_h/2 - image_center[1]
    rotated_mat = cv2.warpAffine(mat, rotation_mat, (bound_w, bound_h))
    return rotated_mat

model = tf.keras.models.Sequential([
    tf.keras.layers.Conv2D(64, (3, 3), activation='relu', input_shape=(150, 150, 3)),
    tf.keras.layers.MaxPooling2D(2, 2),
    tf.keras.layers.Conv2D(64, (3, 3), activation='relu'),
    tf.keras.layers.MaxPooling2D(2, 2),
    tf.keras.layers.Conv2D(128, (3, 3), activation='relu'),
    tf.keras.layers.MaxPooling2D(2, 2),
    tf.keras.layers.Flatten(),
    tf.keras.layers.Dense(512, activation='relu'),
    tf.keras.layers.Dense(256, activation='relu'),
    tf.keras.layers.Dense(52, activation=tf.nn.softmax)
])
model.compile(optimizer = tf.train.AdamOptimizer(),
              loss = 'sparse_categorical_crossentropy',
              metrics=['accuracy'])
model.load_weights("model7.h5")

#All Primary Loaded

img = cv2.imread('Words/76.jpg',0)
thresh = cv2.threshold(img, 0, 255, cv2.THRESH_OTSU|cv2.THRESH_BINARY_INV)[1]
#cv2.imshow("Tets",thresh)
#cv2.waitKey(0)
#cv2.destroyAllWindows()
kernel = np.ones((2,2), np.uint8)
img_erode = cv2.erode(thresh, kernel, iterations = 1)
rot = img_erode
plt.imshow(thresh)
rotat = 10
_, contours, hierarchy = cv2.findContours(rot.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
upy = []
sumy = 0
for contour in contours:
    (x, y, w, h) = cv2.boundingRect(contour)
    if cv2.contourArea(contour) > 100:
        upy.append(y)
for i in range(len(upy)-1):
    sumy = upy[i+1]-upy[i]
sumy = abs(sumy)
while True:
    rot = rotateImage(rot,rotat)
    _, contours, hierarchy = cv2.findContours(rot, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
    val = []
    nsumy = 0
    for contour in contours:
        if cv2.contourArea(contour) > 100:
            val.append(cv2.boundingRect(contour))
    
    val = np.array(val).T.tolist()
    val[2] = list(map(add, val[2], val[0]))
    val[3] = list(map(add, val[3], val[1]))
    rot = rot[min(val[1])-50:max(val[3])+50,min(val[0])-50:max(val[2])+50]
    for i in range(len(upy)-1):
        nsumy = val[1][i+1]-val[1][i]
    nsumy= abs(nsumy)
    if nsumy<1:
        break
    err = nsumy-sumy
    if err>0:
        rotat = -rotat/2
    sumy=nsumy

output = rot.copy()
_, contours, hierarchy = cv2.findContours(rot, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
val = []
nval = []
dval = []
for contour in contours:
    if cv2.contourArea(contour) > 100:
        val.append(cv2.boundingRect(contour))
val = np.array(val).T.tolist()
val[2] = list(map(add, val[2], val[0]))
val[3] = list(map(add, val[3], val[1]))
val = np.array(val).T.tolist()
for i in range(len(val)):
    for j in range(len(val)):
        if i != j:
            if val[i][0]<=val[j][0]<=val[i][2]:
                val[i][1] = min(val[i][1],val[j][1])
                val[i][2] = max(val[i][2],val[j][2])
                val[i][3] = max(val[i][3],val[j][3])
                dval.append(j)
print(dval)
if dval is not None:
    for i in dval:
        del val[i]
val = np.array(val).T.tolist()
val[2] = np.subtract(val[2], val[0])
val[3] = np.subtract(val[3], val[1])
val = np.array(val).T.tolist()
val.sort()

letter=[]
i=0
for itr in val:
    if cv2.contourArea(contour) > 100:
        m=0
        #cv2.rectangle(output, (itr[0], itr[1]), (itr[0] + itr[2], itr[1] + itr[3]), (70,0,70), 3)
        ltr = rot[itr[1]:itr[1]+itr[3],itr[0]:itr[0]+itr[2]]
        ltr = cv2.resize(ltr,(70,70),interpolation = cv2.INTER_AREA)
        ltr = cv2.threshold(ltr, 0, 255, cv2.THRESH_OTSU|cv2.THRESH_BINARY)[1]
        ltr = Image.fromarray(ltr)
        ltr = ImageOps.invert(ltr)
        ltr = ltr.convert('RGB')
        ltr = ImageOps.fit(ltr, (150,150), Image.ANTIALIAS)
        cv2.imwrite(filename='Letters/'+str(i)+'_img41.jpg', img=np.float32(ltr))
        #ltr.show()
        ltr = np.expand_dims(ltr,axis=0)
        val = model.predict(ltr)
        val = np.where(val == np.amax(val))
        if(val[1][0]>25):
            m=6
        print(chr(val[1][0]+65+m),end='')
        letter.append(ltr)
        i=i+1

#Below are all tests

img = image.load_img("img.png",target_size=(150,150))

img  = image.img_to_array(img)
img = np.expand_dims(img,axis=0)
res = model.predict(img)
res = np.where(res == np.amax(res))
print(chr(res[1][0]+65+6))

'''
import os
i = 0
for filename in os.listdir("Words/"): 
    dst = str(i) + ".jpg"
    src ='Words/'+ filename 
    dst ='Words/'+ dst 
    os.rename(src, dst) 
    i += 1
'''

'''
num = 11
m=0
let = "a" #chr(ord(ch) + 1)
for i in range(26):
    if i==26:
        m=6
    dirs = 'Letters/'+ chr(ord(let) + m +i)+ chr(ord(let) + m +i)
    os.mkdir(dirs)
'''

